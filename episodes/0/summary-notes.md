### ✅ WebAssembly продовжує розширювати можливості фронтенду через 10 років після появи.
[WebAssembly Still Expanding Frontend Uses 10 Years Later](https://thenewstack.io/webassembly-still-expanding-frontend-uses-10-years-later/)

**Основна ідея:** WebAssembly (Wasm) продовжує розширювати свої можливості у фронтенд-розробці, пропонуючи значні переваги у продуктивності та кросплатформенній сумісності.

**Сценарії використання:**
*   **Бізнес-логіка:** Один з найпопулярніших сценаріїв — написання бізнес-логіки на одній мові та її використання на різних платформах (веб, мобільні, сервер) через WebAssembly. Це дозволяє уникнути переписування коду. Приклад: Snapchat використовує цей підхід для своєї програми.
*   **Обчислювально-інтенсивні завдання:** Wasm може виконувати код швидше за JavaScript, що робить його ідеальним для завдань, що вимагають значних обчислювальних ресурсів.
*   **Обробка тексту (Hyphenation):** Для мов, де браузер не підтримує правила переносів, Wasm-модуль може обробляти текст і правильно розставляти переноси.
*   **Криптографія:** Wasm використовується для реалізації криптографічних функцій, таких як шифрування та дешифрування.
*   **Обробка зображень:** Автор статті згадує власну бібліотеку для перетворення растрових зображень у векторні, де Wasm використовується для виконання ресурсомістких операцій у фоновому потоці, не блокуючи основний інтерфейс.
*   **Робота з рядками JavaScript:** Wasm 3 пропонує ефективніший спосіб роботи з рядками JavaScript, дозволяючи "запозичувати" вже існуючі в JavaScript реалізації (наприклад, для роботи з Unicode) замість того, щоб компілювати їх у Wasm.
*   **Serverless функції:** Wasm може використовуватися для підтримки "serverless" функцій на фронтенді. Завдяки швидкому запуску, Wasm-рантайм на сервері може швидко обробити запит і "заснути", що робить його ефективним для таких сценаріїв.

**Інструменти для компіляції в Wasm:**
*   **Emscripten:** Популярний інструмент для портування C/C++ коду (особливо ігор) у браузер.
*   **LLVM:** Може використовуватися для компіляції C, C++ та Rust у WebAssembly.
*   **Binaryen:** Дозволяє оптимізувати та трансформувати Wasm-бінарники для зменшення розміру коду та покращення продуктивності.
*   **wasm-pack:** Для компіляції, тестування та публікації Rust-пакетів на основі Wasm в npm.
*   **AssemblyScript:** Надає синтаксис, подібний до TypeScript, який компілюється безпосередньо в Wasm.

### Чи може штучний інтелект писати специфікації доступності.
[Can AI write accessibility specs?](https://gerireid.com/blog/can-ai-write-accessibility-specs/)

**Основна ідея:** Автор експериментує зі створенням інструменту на основі ШІ (GPT-4o-mini) для генерації специфікацій доступності для веб-компонентів, але стикається з проблемами точності та етичними дилемами.

**Процес створення:**
1.  **Налаштування API-запиту:** Створено функцію JavaScript, яка викликає OpenAI API через Netlify.
2.  **Написання ефективного запиту (prompt):** Початкові запити давали ненадійні результати, ШІ "галюцинував" і вигадував компоненти. Проблему частково вирішило зниження "температури" моделі до нуля, що робить відповіді більш точними та менш схильними до вигадок.
3.  **Покращення за допомогою RAG (Retrieval Augmented Generation):** Щоб уникнути загальних порад, автор додав до запиту перевірені джерела (документація WCAG, ARIA, MDN, Apple HIG, Material Design). Функція знаходить відповідний компонент у локальних JSON-файлах, додає посилання на надійні джерела до запиту, і вже на основі цієї інформації генерує відповідь.

**Результати та висновки:**
*   **Проблема галюцинацій:** Навіть з RAG та низькою температурою, ШІ все ще генерує неправдиву інформацію, яка виглядає авторитетно. Наприклад, код у розділі семантичного HTML був разюче неправильним.
*   **Ненадійність джерел:** Оскільки більшість веб-сайтів (94% з мільйона найкращих за версією WebAIM) мають помилки доступності, навчальні дані для ШІ є недосконалими, що ставить під сумнів можливість отримання 100% правильних відповідей.
*   **Необхідність перевірки:** Автор дійшов висновку, що все одно доводиться перевіряти інформацію вручну, що знецінює ідею автоматизації. Коли йдеться про доступ до критично важливої інформації, людський нагляд є незамінним.
*   **Екзистенційна криза та етика:** Автор розмірковує про етичні та екологічні наслідки використання ШІ, включаючи невидиму працю низькооплачуваних робітників, потенційну втрату робочих місць та "брудне" відчуття від "згодовування" експертного контенту машині OpenAI.

### ✅ Тестування HTML-вебкомпонентів з Light DOM: це простіше, ніж здається!
[Testing HTML Light DOM Web Components: Easier Than Expected!](https://cloudfour.com/thinks/testing-html-light-dom-web-components-easier-than-expected/)

**Основна ідея:** Стаття описує досвід команди у тестуванні HTML веб-компонентів, створених за допомогою Light DOM. Автор ділиться інструментами, патернами та висновками, які зробили цей процес напрочуд простим та ефективним.

**Стек для тестування:**
*   **Vitest:** фреймворк для тестування.
*   **Testing Library:** для запитів до DOM та симуляції подій.
*   **jsdom:** для симуляції середовища браузера.
*   **Lit `html` та `render()`:** для рендерингу компонентів у тестах.
*   **vitest-axe:** для автоматизованої перевірки правил доступності.
*   **ESLint плагіни:** для дотримання найкращих практик тестування.

**Ключові моменти та патерни:**
*   **Light DOM спрощує тестування:** Використання Light DOM дозволило тестувати веб-компоненти так само, як і звичайні компоненти фреймворків (React, Vue), оскільки не було потреби "пробиватися" через Shadow DOM.
*   **Тестування доступності:**
    *   Кожен компонент мав тест на порушення доступності за допомогою `vitest-axe`.
    *   За замовчуванням використовувалися `ByRole` запити з Testing Library, що сприяє написанню більш доступного коду.
    *   Додавалися перевірки наявності та значень ARIA-атрибутів.
    *   Тестувалося керування фокусом.
*   **Тестування подій:** Використовувався `vi.fn()` з Vitest для створення "шпигунів" (spies) і перевірки, чи були викликані обробники подій з правильними даними.
*   **Спільні шаблони для тестів та Storybook:** Використання Lit `html` шаблонів дозволило перевикористовувати розмітку як для тестів, так і для історій у Storybook, що зменшило дублювання коду.
*   **Організація тестів:** Тестові файли розміщувалися поруч із файлами компонентів (`*.test.ts`), що полегшувало їх знаходження та підтримку.
*   **Уникнення витоку стану між тестами:** Використання `beforeEach` та `afterEach` для очищення DOM та скидання стану перед кожним тестом.

**Висновок:** Вибір на користь Light DOM веб-компонентів був абсолютно правильним рішенням. Це зробило процес тестування не складнішим, ніж для компонентів, специфічних для фреймворків, а іноді навіть простішим.

### ✅ Як використовувати ChatGPT Atlas для налагодження, тестування та інших завдань у фронтенді.
[How to use ChatGPT Atlas for frontend debugging, testing, and more](https://blog.logrocket.com/chatgpt-atlas-for-frontend/)

**Основна ідея:** Стаття досліджує, чи може новий браузер Atlas від OpenAI, з інтегрованим ШІ, справді покращити робочий процес фронтенд-розробника, порівнюючи його з традиційними інструментами, як-от Chrome DevTools.

**Що таке Atlas?**
Atlas — це браузер на базі Chromium з вбудованим ChatGPT, який має доступ до DOM, мережевої активності та стану сторінки. Це дозволяє ШІ надавати більш релевантні відповіді та зменшує необхідність перемикатися між різними інструментами.

**Порівняння Atlas та Chrome DevTools:**
*   **Інспекція React/Vue:** Atlas не має вбудованої підтримки для розширень DevTools, як-от React/Vue DevTools. Для інспекції компонентів доводиться використовувати обхідні шляхи, наприклад, спеціальні скрипти або бібліотеки (`@welldone-software/why-did-you-render`).
*   **Відладка CSS:** Atlas добре справляється з відладкою CSS, оскільки ШІ може аналізувати DOM і пропонувати конкретні виправлення. Наприклад, він може знайти елемент, що викликає горизонтальну прокрутку, і запропонувати CSS-правила для виправлення.
*   **Аналіз помилок JavaScript:** Atlas може аналізувати помилки в консолі та надавати пояснення та варіанти виправлення, що прискорює процес відладки.
*   **Режим "Агента" (Agent mode):** Це найпотужніша функція Atlas, яка дозволяє ШІ виконувати дії в браузері:
    *   **Автоматизоване тестування:** Можна дати агенту інструкції для перевірки функціональності (наприклад, "переконайся, що валідаційні повідомлення з'являються правильно").
    *   **Документація та онбординг:** Агент може проаналізувати документацію дизайн-системи та створити її короткий опис.
    *   **Автоматизація робочих процесів:** Можна доручити агенту створювати завдання в таск-трекерах (Linear, Jira) на основі документів.
    *   **Інтеграція між інструментами:** Агент може порівнювати дизайн-токени в Figma з реалізованими в CSS.

**Безпека та приватність:**
Atlas надає контроль над доступом агента: можна обирати, чи буде він "залогінений" у ваших акаунтах, а також керувати "спогадами" браузера.

**Коли використовувати Atlas, а коли Chrome:**
*   **Chrome:** для відладки, специфічної для фреймворків (React Hooks, Vue reactivity), оскільки він підтримує відповідні розширення DevTools.
*   **Atlas:** коли ви знаєте, що щось зламано, але не знаєте, з чого почати; для розуміння "чому" виникла помилка; для відладки коду, з яким ви не знайомі.

**Висновок:** Atlas не замінює Chrome DevTools повністю, але є потужним доповненням до інструментарію розробника, особливо завдяки режиму "Агента" та можливостям ШІ-асистента для відладки.

### Найкращий спосіб створити ефект паралаксного прокручування в 2026 році.
[The best way to create a parallax scrolling effect in 2026](https://www.builder.io/blog/parallax-scrolling-effect)

**Основна ідея:** Стаття стверджує, що для створення ефекту паралакс-прокрутки не потрібні сторонні бібліотеки (GSAP, Three.js, WebGL). Найкращий підхід — це використання ванільного JavaScript, `refs` та слухача подій прокрутки.

**Що таке паралакс-прокрутка?**
Це техніка, за якої фонові зображення рухаються повільніше, ніж контент на передньому плані, створюючи ілюзію глибини.

**Коли використовувати, а коли ні:**
*   **Використовувати:** для створення візуально привабливих сайтів, де ефект підтримує розповідь (наприклад, сайти Parable VC та Firewatch).
*   **Не використовувати:** на сайтах з великою кількістю контенту, де користувачам потрібно швидко сканувати інформацію; якщо немає можливості підтримати налаштування `reduced motion`; при стислих термінах.

**Найкращий підхід до реалізації:**
1.  **Структура шарів:** Створити кілька шарів (наприклад, фоновий, середній, передній) за допомогою `div` з фоновими зображеннями та `position: fixed`.
2.  **Обробник прокрутки:**
    *   Використовувати `useRef` для отримання прямих посилань на DOM-елементи шарів.
    *   Створити `useEffect` для додавання слухача події `scroll`.
    *   В обробнику зчитувати `window.scrollY` і оновлювати `transform: translateY()` для кожного шару з різним коефіцієнтом. Це створює ефект різної швидкості руху.

**Чому цей метод ефективний:**
*   **Простота:** Немає залежностей, лише пряма маніпуляція DOM.
*   **Продуктивність:** `transform` виконується на окремому потоці композитора, що забезпечує плавні 60fps навіть на мобільних пристроях. Немає оновлень стану та перерендерів.

**Альтернативні підходи:**
*   **Прокрутка з "пом'якшенням" (easing):** Використання `requestAnimationFrame` та лінійної інтерполяції (lerp) для створення більш плавного руху. Використовує більше CPU і додає невелику затримку.
*   **Чисті CSS анімації, керовані прокруткою (`scroll-driven animations`):** Використання `animation-timeline: scroll()` для прив'язки анімації до прокрутки. Це декларативний підхід, але може бути менш гнучким.
*   **`IntersectionObserver` з прогресом прокрутки:** Більш складний метод, який відстежує видимість елемента і розраховує прогрес прокрутки всередині нього.

**Висновок:** Прямий підхід з використанням `transform` та слухача подій прокрутки є найпростішим, найпродуктивнішим та рекомендованим для більшості проектів у 2026 році.

### Grid: використання grid-template-areas для візуалізації розмітки коду.
[Grid: how grid-template-areas offer a visual solution for your code](https://webkit.org/blog/17620/grid-how-grid-template-areas-offer-a-visual-solution-for-your-code/)

**Основна ідея:** Стаття пояснює, як використовувати властивість `grid-template-areas` в CSS Grid для створення візуально зрозумілих та легких у підтримці макетів, на противагу використанню grid-ліній.

**Проблема з grid-лініями:** Хоча використання grid-ліній є потужним інструментом, код може бути важким для візуалізації, особливо у складних макетах.

**Рішення з `grid-template-areas`:**
Ідея полягає в тому, щоб дати імена кожному елементу, який потрібно розмістити на сітці, а потім візуально розташувати ці імена в коді.

**Кроки для реалізації:**
1.  **Присвоїти імена елементам:** Кожному елементу, який буде частиною сітки, потрібно присвоїти унікальне ім'я за допомогою властивості `grid-area`.
    ```css
    .product-1 {
      grid-area: product-1;
    }
    .add-ons {
      grid-area: add-ons;
    }
    ```
2.  **Визначити макет за допомогою `grid-template-areas`:** У контейнері сітки (`display: grid`) використовується властивість `grid-template-areas`, де ви "малюєте" макет за допомогою раніше визначених імен.
    *   Кожен рядок у значенні властивості представляє рядок сітки.
    *   Кожне ім'я, розділене пробілом, представляє комірку сітки.
    *   Щоб елемент займав кілька комірок (span), його ім'я повторюється в цих комірках.

    **Приклад:**
    Для макета з трьома колонками, де `add-ons` займає дві комірки по висоті, а `testimonial` — дві по ширині, код виглядатиме так:
    ```css
    .pricing-options {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 2em;
      grid-template-areas:
        "product-1 product-2 add-ons"
        "testimonial testimonial add-ons";
    }
    ```

**Переваги `grid-template-areas`:**
*   **Візуальна ясність:** Вся логіка розміщення елементів знаходиться в одному місці і візуально представляє кінцевий макет.
*   **Легкість у зміні:** Щоб змінити макет, достатньо переставити імена в "малюнку" `grid-template-areas`.
*   **Самодокументований код:** Макет стає зрозумілим з першого погляду на CSS.

**Висновок:** `grid-template-areas` є чудовою альтернативою grid-лініям, яка робить код більш читабельним та легким для підтримки, особливо для візуального представлення структури сторінки.

### Як створити модульну та підтримувану CSS-архітектуру з @layer.
[How to create a modular and maintainable CSS setup with @layer](https://techhub.iodigital.com/articles/how-to-create-a-modular-css-architecture-with-layer)

**Основна ідея:** Стаття пояснює, як використовувати CSS-директиву `@layer` для створення чіткої, модульної та легко підтримуваної архітектури стилів, що вирішує проблеми зі специфічністю та порядком завантаження, які часто призводили до використання `!important`.

**Проблеми минулого:**
*   Раніше для організації CSS використовували препроцесори, як-от Sass, де порядок `@import` визначав пріоритет стилів.
*   Без чіткої архітектури з часом ставало все важче перевизначати стилі, що призводило до складних селекторів та зловживання `!important`.

**Рішення з `@layer`:**
Директива `@layer`, представлена у 2022 році, дозволяє керувати ієрархією каскаду безпечно та передбачувано.

**Як це працює:**
1.  **Визначення порядку шарів:** На початку CSS-файлу ви визначаєте порядок шарів. Цей порядок є важливішим за специфічність селекторів.
    ```css
    @layer settings, base, utilities, components, patches;
    ```
    Стилі у шарі `patches` матимуть вищий пріоритет, ніж стилі у шарі `components`, навіть якщо селектори в `components` більш специфічні.

2.  **Імпорт стилів у відповідні шари:** Ви можете імпортувати файли стилів і призначати їх до певного шару.
    ```css
    @import url('variables/all.css') layer(settings);
    @import url('base/all.css') layer(base);
    @import url('components/all.css') layer(components);
    @import url('patches/all.css') layer(patches);
    ```

3.  **Розміщення стилів у шарах:** Ви також можете визначати стилі безпосередньо всередині блоків `@layer`.
    ```css
    @layer components {
      .button {
        color: blue;
      }
    }

    @layer patches {
      .special-button {
        color: red; /* Цей стиль перевизначить .button, якщо застосовано до того ж елемента */
      }
    }
    ```

**Переваги `@layer`:**
*   **Контроль над каскадом:** Порядок шарів, а не специфічність, визначає пріоритет. Це робить архітектуру більш передбачуваною.
*   **Ізоляція:** Стилі ізольовані в межах своїх шарів, що зменшує ризик несподіваних конфліктів.
*   **Чиста архітектура:** Заохочує до створення чіткої структури (наприклад, `settings`, `base`, `components`, `utilities`, `patches`), яка є самодокументованою.
*   **Нативна підтримка:** Підтримується всіма основними браузерами, а старі браузери просто ігнорують цю директиву.

**Висновок:** Комбінація `@layer` та `@import` надає нативний контроль над каскадом CSS, замінюючи потребу в препроцесорах для цієї задачі та допомагаючи створювати більш надійні та масштабовані таблиці стилів.

### CSS random(): глибше розуміння через експерименти.
[More CSS random() Learning Through Experiments](https://frontendmasters.com/blog/more-css-random-learning-through-experiments/)

**Основна ідея:** Стаття досліджує творчі можливості нової CSS-функції `random()`, яка на момент написання була доступна лише в Safari Technical Preview. Автор ділиться трьома експериментами, що демонструють, як `random()` може додати унікальну текстуру та динаміку у веб-дизайн.

**Що таке `random()`?**
Це функція CSS, яка генерує випадкове значення в заданому діапазоні. Наприклад, `random(10px, 50px)` поверне випадкове значення між 10 та 50 пікселями.

**Експерименти:**
1.  **Обертове поле зірок (Rotating Star Field):**
    *   **Ідея:** Створити ефект обертового зоряного поля, схожий на той, що використовується у грі "BALL x PIT".
    *   **Реалізація:** Створюється велика кількість `<div>` (зірок), які розміщуються в центрі екрана. Кожній зірці надається випадкова висота (`height: random(...)`) та випадковий кут обертання (`rotate: random(...)`). Зірки розміщуються на кінцях цих `div`-контейнерів. Потім контейнери обертаються навколо центру, створюючи динамічний ефект.
    *   **Результат:** Красиве, рандомізоване поле зірок, яке можна далі анімувати, змінюючи кольори, тіні та розміри.

2.  **Паралакс зірок (Parallax Stars):**
    *   **Ідея:** Створити ефект паралаксу, прив'язавши анімацію зірок до прокрутки сторінки.
    *   **Реалізація:** Зірки (знову `<div>`) розміщуються у випадкових позиціях (`top: random(...)`, `left: random(...)`). Потім вони діляться на три групи. Кожна група анімується з різною швидкістю за допомогою `scroll-driven animations`, створюючи ілюзію глибини.
    *   **Результат:** Ефект паралаксу, де зірки на "різних" відстанях рухаються з різною швидкістю під час прокрутки.

3.  **Горизонтальні лінії з точок (Horizontal Rules of Gridded Dots):**
    *   **Ідея:** Поєднати `random()` з функцією `steps()` для створення "крокової" анімації, де елементи не плавно, а стрибкоподібно змінюють своє положення.
    *   **Реалізація:** Створюється сітка з точок (`<div>`), початкове вертикальне положення яких є випадковим (`top: random(...)`). За допомогою `view-timeline` анімація прив'язується до видимості елемента на екрані. Функція `animation-timing-function: steps(5)` змушує точки "стрибати" у фінальне положення, а не плавно переміщатися.
    *   **Результат:** Задовільний ефект, коли випадково розкидані точки вирівнюються в ідеальну лінію під час прокрутки.

**Висновок:** Функція `random()` є чудовим доповненням до CSS, що дозволяє легко додавати динамічність та унікальність у веб-інтерфейси, створюючи відчуття "живого" дизайну.

### «Найбільш ненависна» функція CSS: asin(), acos(), atan() та atan2().
[The “Most Hated” CSS Feature: asin(), acos(), atan() and atan2()](https://css-tricks.com/the-most-hated-css-feature-asin-acos-atan-and-atan2/)

**Основна ідея:** Стаття є частиною серії, яка намагається змінити негативне ставлення до тригонометричних функцій в CSS, демонструючи їхню корисність на практичних прикладах. Цей випуск фокусується на обернених тригонометричних функціях: `asin()`, `acos()`, `atan()` та `atan2()`.

**Що таке обернені тригонометричні функції?**
Вони роблять протилежне до звичайних тригонометричних функцій: якщо `sin()` бере кут і повертає відношення сторін, то `asin()` (арксинус) бере відношення і повертає кут.

*   `asin(x)` та `acos(x)`: приймають значення від -1 до 1.
*   `atan(x)`: приймає будь-яке число від `-Infinity` до `Infinity` і повертає кути від -90° до 90°. Це робить її більш універсальною.
*   `atan2(y, x)`: найпотужніша з них. Вона приймає дві координати (y та x) і повертає кут у будь-якій точці площини (всі 360°), вирішуючи проблему обмеженого діапазону `atan()`.

**Практичні застосування:**

1.  **Стеження за мишею (Following the mouse):**
    *   **Завдання:** Зробити так, щоб очі персонажа (на ім'я Helpy) завжди дивилися на курсор миші.
    *   **Реалізація:**
        1.  За допомогою JavaScript отримуються координати миші (`event.clientX`, `event.clientY`) і передаються в CSS як кастомні властивості (`--m-x`, `--m-y`).
        2.  Визначається центр очей персонажа.
        3.  За допомогою `atan2()` розраховується кут між центром очей та позицією миші: `atan2(var(--m-y) - var(--eye-y), var(--m-x) - var(--eye-x))`.
        4.  Цей кут застосовується до властивості `rotate` очей, змушуючи їх обертатися в напрямку курсора.

2.  **Отримання числових значень з одиниць виміру (Type casting):**
    *   **Завдання:** Перетворити значення з одиницями (наприклад, `100vw`) на чисте число.
    *   **Реалізація:** Використовується трюк, описаний Jane Ori, що поєднує `atan2()` та `tan()`:
        ```css
        :root {
          --100vw: 100vw;
          --int-width: calc(10000 * tan(atan2(var(--100vw), 10000px)));
        }
        ```
        Тепер змінна `--int-width` містить ширину вьюпорта як ціле число, яке можна використовувати в розрахунках.

**Висновок:** Функції `atan()` та особливо `atan2()` є надзвичайно потужними інструментами в CSS, які дозволяють реалізовувати складну інтерактивну поведінку (наприклад, стеження за курсором) та виконувати корисні перетворення типів, що значно розширює можливості CSS.

### React 19.2: Асинхронний перехід нарешті став реальністю.
[React 19.2: The async shift is finally here](https://blog.logrocket.com/react-19-2-the-async-shift/)

**Основна ідея:** React 19.2 кардинально змінює підхід до роботи з асинхронними операціями, відходячи від застарілого патерну `useEffect` + `fetch` до нової системи, побудованої на `use()`, `<Suspense>`, `useTransition()` та View Transitions. Це робить асинхронну логіку першокласною архітектурною особливістю фреймворку.

**Старий підхід: `useEffect` + `isLoading`**
Традиційний спосіб завантаження даних у React включав `useEffect` для виконання `fetch`-запитів та ручне керування станами завантаження (`isLoading`, `error`). Цей підхід був громіздким, схильним до помилок (race conditions) і призводив до менш оптимального користувацького досвіду.

**Нові асинхронні примітиви:**

1.  **`use()` + `Promise`: Основний патерн**
    *   Хук `use()` дозволяє "розпаковувати" значення з промісу безпосередньо в компоненті. Якщо проміс ще не вирішений, `use()` "кидає" його вгору до найближчого `<Suspense>`.
    *   Це дозволяє писати асинхронний код так, ніби він синхронний, значно спрощуючи логіку.

2.  **`<Suspense>`: Декларативне керування станами завантаження**
    *   Компонент `<Suspense>` "ловить" проміси, кинуті `use()`, і показує `fallback` (наприклад, спіннер), поки дані завантажуються.
    *   Це дозволяє уникнути ручного керування станом `isLoading` і створює більш плавний користувацький досвід, оскільки UI оновлюється декларативно.

3.  **`useTransition()` + `action`: Плавніші взаємодії**
    *   Хук `useTransition()` дозволяє позначати оновлення стану як "нетермінові". Це корисно для дій, які ініціюють асинхронні операції (наприклад, відправка форми).
    *   Він надає прапорець `isPending`, який можна використовувати для відображення індикатора завантаження, не блокуючи при цьому UI.

4.  **View Transitions: GPU-прискорена анімація**
    *   React 19.2 (в експериментальній гілці) додає підтримку нативного API View Transitions.
    *   Це дозволяє створювати плавні, GPU-прискорені анімації під час завантаження асинхронного контенту, додаючи всього кілька рядків CSS.

**Чому це важливо для команд:**
*   **Простіший код:** Нові примітиви зменшують кількість шаблонного коду та роблять логіку більш зрозумілою.
*   **Менше помилок:** Фреймворк бере на себе більше роботи з керування асинхронністю, зменшуючи ризик помилок.
*   **Кращий UX:** UI стає більш відгукливим, оновлюється на вимогу та має плавні анімації.

**Висновок:** React 19.2 вирішує одну з найбільших проблем фреймворку. "Асинхронний зсув" вже відбувся, і командам варто переходити на нові інструменти для створення сучасних, швидких та надійних додатків.

### Brimstone — новий JavaScript рушій, написаний на Rust.
[Brimstone](https://github.com/Hans-Halverson/brimstone)

**Основна ідея:** Brimstone — це новий JavaScript-рушій, створений з нуля на мові програмування Rust. Проект має на меті повну підтримку специфікації ECMAScript і, незважаючи на те, що він ще в розробці, вже реалізує більшу частину мови (>97% тестів test262).

**Ключові особливості та архітектура:**
*   **Написаний на Rust:** Вибір Rust забезпечує високу продуктивність та безпеку пам'яті.
*   **Реалізація з нуля:** Майже всі компоненти рушія (парсер, рушій регулярних виразів, збирач сміття) написані з нуля з мінімальними залежностями. Єдиний значний виняток — використання бібліотеки `ICU4X` для інтернаціоналізації.
*   **Байт-код VM:** Рушій використовує віртуальну машину, що працює на байт-коді. Архітектура значною мірою натхненна дизайном Ignition з V8.
*   **Збирач сміття (Garbage Collector):** Використовується ущільнюючий (compacting) збирач сміття, написаний на "дуже небезпечному" Rust.
*   **Натхнення:** Дизайн рушія черпає натхнення з V8 (рушій Chrome) та LibJS (рушій браузера SerenityOS).

**Стан проекту:**
*   **Готовність:** Проект є "work in progress" і ще не готовий для використання в продакшені.
*   **Підтримка функцій:** Реалізовано всі функції до стандарту ES2024, а також усі пропозиції 4-ї стадії (stage 4) станом на лютий 2025 року, за винятком:
    *   `SharedArrayBuffer`
    *   `Atomics`
*   **Тестування:** Проект активно тестується за допомогою офіційного набору тестів `test262`, а також має власні інтеграційні, юніт- та фаззінг-тести.

**Як використовувати:**
*   Стандартні команди `cargo` для збірки (`cargo build`) та запуску (`cargo run`).
*   Виконання JavaScript-файлів здійснюється через бінарний файл `bs`: `./target/debug/bs ./hello.js`.

**Висновок:** Brimstone є амбітним проектом, що демонструє можливість створення сучасного та продуктивного JavaScript-рушія на Rust. Хоча він ще не готовий для широкого загалу, його прогрес та архітектурні рішення є значним досягненням у спільноті розробників системного програмного забезпечення.

### Піраміда React-компонентів: криза надмірної розробки.
[The React Component Pyramid Scheme: An Over-Engineering Crisis](https://thenewstack.io/the-react-component-pyramid-scheme-an-over-engineering-crisis/)

**Основна ідея:** Стаття критикує поширену в React-спільноті одержимість принципом DRY (Don't Repeat Yourself) та надмірною абстракцією, що призводить до створення складних, крихких та важких для розуміння компонентів. Автор закликає до "пост-реюз" мислення, де пріоритетом є ясність та ізоляція, а не сліпе уникнення дублювання.

**Проблеми, що виникають через надмірну абстракцію:**
1.  **"Суп із пропсів" (Prop Soup):** У спробі зробити компонент максимально перевикористовуваним, розробники перевантажують його десятками пропсів для обробки всіх можливих варіацій. Це робить компонент складним у використанні та підтримці.
2.  **Хибна складність:** Принцип DRY, доведений до абсурду, призводить до створення "мега-компонентів", які об'єднують схожу, але не ідентичну логіку (наприклад, форми логіну та реєстрації). Кожна невелика зміна в такому компоненті ризикує зламати кілька функціональностей одночасно.
3.  **Небезпека передчасної абстракції:** Абстракції, створені "про запас" (бо "можливо, це знадобиться десь ще"), часто є спекулятивними. Вони додають шари складності, які важко зрозуміти та ще важче видалити, оскільки вони "можуть бути корисними колись".
4.  **Втрата контексту:** Надмірна абстракція відриває код від його контексту, змушуючи розробника робити "ментальні стрибки" між різними файлами та рівнями абстракції, щоб зрозуміти, що відбувається.

**Пропонований підхід ("Пост-реюз" мислення):**
*   **Навмисне дублювання:** Іноді дублювання коду є прагматичним рішенням. Воно зберігає ясність та дозволяє компонентам розвиватися незалежно. Автор пропонує дотримуватися принципу WET (Write Everything Twice) як противаги DRY.
*   **Абстракції мають виникати природно:** Хороші абстракції народжуються з реальних, повторюваних патернів (правило трьох: абстрагуй, коли бачиш однаковий код у трьох або більше місцях).
*   **Пріоритет ясності над розумністю:** Найкращий компонент — не той, який можна використати скрізь, а той, який можна зрозуміти миттєво.
*   **Прості, самодостатні компоненти:** Здорові системи — це не піраміди, побудовані на шарах абстракції, а "сади" з простих, незалежних компонентів.

**Висновок:** Спільноті React потрібно переосмислити, що таке "хороша" архітектура. Справжня підтримуваність полягає не в тому, скільки рядків коду ви розділили, а в тому, наскільки легко зрозуміти кожну частину в ізоляції. Ясність має переважати над хитромудрістю.

### Анонс Angular v21.
[Announcing Angular v21](https://blog.angular.dev/announcing-angular-v21-57946c34f14b)

**Основна ідея:** Angular v21 представляє значні оновлення, спрямовані на покращення досвіду розробників, підвищення продуктивності та інтеграцію з інструментами ШІ. Ключові нововведення включають експериментальні Signal Forms, бібліотеку доступних компонентів Angular Aria, стабільний Vitest як стандартний тест-ранер та відмову від `zone.js` за замовчуванням.

**Основні нововведення:**

1.  **Експериментальні Signal Forms:**
    *   Новий підхід до створення форм, побудований на основі Signals.
    *   Пропонує більш масштабований, композитний та реактивний досвід роботи з формами.

2.  **Angular Aria (Developer Preview):**
    *   Нова бібліотека "безголових" (unstyled) UI-компонентів, створених з пріоритетом на доступність.
    *   Розробники можуть використовувати ці компоненти та стилізувати їх на свій розсуд.
    *   На старті доступно 8 патернів, що включають 13 компонентів (Accordion, Combobox, Grid, Menu, Tabs та ін.).

3.  **Інструменти для ШІ-агентів (MCP Server):**
    *   MCP (Model Context Protocol) сервер, вбудований в Angular CLI, став стабільним.
    *   Він надає ШІ-агентам (наприклад, в IDE) контекст про сучасний Angular та ваш додаток.
    *   Інструменти включають: `get_best_practices`, `search_documentation`, `find_examples`, інструмент для міграції на zoneless (`onpush_zoneless_migration`) та інтерактивний ШІ-репетитор (`ai_tutor`).
    *   Це дозволяє ШІ використовувати навіть найновіші функції Angular, долаючи проблему "зрізу знань".

4.  **Vitest як стандартний тест-ранер:**
    *   Інтеграція з Vitest тепер стабільна і готова до використання в продакшені.
    *   Vitest стає стандартним тест-ранером для нових додатків Angular.

5.  **Zoneless за замовчуванням:**
    *   Нові додатки, створені за допомогою Angular CLI, більше не включатимуть `zone.js` за замовчуванням.
    *   Перехід на zoneless change detection, керований сигналами, забезпечує кращі Core Web Vitals, нативну підтримку `async-await`, зменшений розмір бандла та кращу сумісність з екосистемою.

6.  **Оновлення документації:**
    *   Значно перероблено документацію на `angular.dev`, включаючи розділи про маршрутизацію, dependency injection, темізацію Material компонентів та використання Tailwind CSS.
    *   Запущено `angular.dev/ai` — ресурс для створення ШІ-додатків з Angular.

**Висновок:** Angular v21 є важливим кроком у модернізації фреймворку, роблячи його більш продуктивним, легким у використанні та готовим до майбутнього веб-розробки з ШІ.

### Чи є React(tanstack) Query занадто упередженим? Глибоке занурення: практичні методи отримання даних у реальному житті — Розділ 1.
[Is React(tanstack) Query Too Biased? Deep dive: Real Life Data Fetching Practices — Chapter 1](https://burakdev.com/blogs/is-react-tanstack-query-too-biased-deep-dive-real-life-data-fetching-practices-chapter-1)

**Основна ідея:** Стаття є першою частиною глибокого аналізу практик отримання даних у сучасних веб-додатках, з особливим акцентом на React Query (тепер Tanstack Query). Автор розглядає еволюцію data fetching, порівнює різні підходи та пояснює, чому React Query став де-факто стандартом для багатьох розробників.

**Що таке "query"?**
Автор починає з роз'яснення самого терміну "query" у різних контекстах:
*   **Веб-пошуковий запит:** приклад того, як запити використовуються для отримання релевантної інформації.
*   **Query String (рядок запиту в URL):** підкреслюється важливість використання URL як "публічного менеджера стану", що відповідає принципам "The Twelve-Factor App" і сприяє масштабованості та безстановості (statelessness).

**Що таке React Query?**
*   React Query позиціонується як бібліотека, що "заповнює відсутні прогалини" у вибірці даних у React.
*   Вона спрощує отримання, кешування, синхронізацію та оновлення серверного стану.
*   Автор підкреслює, що традиційні бібліотеки для керування станом (як-от Redux) не є оптимальними для серверного стану, оскільки вони створені для загальних потреб.

**Еволюція отримання даних у JavaScript:**
Автор розглядає історичний розвиток технологій data fetching:
1.  **XMLHttpRequest (XHR):** старий, громіздкий підхід.
2.  **jQuery `$.ajax`:** значне спрощення порівняно з XHR.
3.  **Fetch API (2015/2016):** нативний, більш сучасний стандарт, що працює з промісами.
4.  **Axios:** популярна бібліотека-обгортка над Fetch API, що надає зручніші функції (наприклад, interceptors).
5.  **SWR та React Query:** бібліотеки, що вводять концепцію кешування, синхронізації та автоматичного оновлення даних.
6.  **React Server Components (RSCs):** нова парадигма, що дозволяє виконувати компоненти на сервері, зменшуючи розмір JS-бандла та покращуючи швидкість завантаження.

**Чому React Query є "легендою"?**
Автор вважає React Query беззаперечним лідером серед усіх технологій data fetching завдяки його потужним можливостям кешування, автоматичного оновлення та синхронізації стану.

**Основний висновок (Bottom line):**
*   Стратегію отримання даних потрібно обирати на основі вимог проекту, його масштабу, бюджету та команди.
*   Немає єдиного правильного рішення для всіх.
*   Важливо розуміти переваги та недоліки кожного підходу.

**Що далі?**
У другій частині автор планує розглянути практичні аспекти реалізації CRUD-додатку за допомогою React Query та більш глибоко зануритися в технічні деталі.

### Боротьба з витоками пам’яті в JavaScript PDF-візуалізаторах: рекомендовані практики та інструкції з налагодження.
[How to Fix Memory Leaks in JavaScript PDF Viewers: Best Practices and Debugging Tips](https://www.syncfusion.com/blogs/post/memory-leaks-in-javascript-pdf-viewer)

**Основна ідея:** Стаття розглядає поширені проблеми витоку пам'яті в JavaScript PDF-переглядачах, пояснює їхні причини, пропонує методи для їх виявлення та виправлення, а також представляє рішення від Syncfusion як ефективну альтернативу.

**Поширені проблеми витоку пам'яті:**

1.  **Криза збоїв (Crash crisis):**
    *   **Проблема:** JavaScript PDF-переглядачі можуть ставати нестабільними під час тривалих сесій або при рендерингу великих документів, що призводить до збоїв. Приклад: відомі проблеми з `PDF.js`, який з часом споживає надмірну кількість пам'яті.
    *   **Рішення:** Раннє виявлення за допомогою інструментів, як-от Chrome DevTools (heap snapshots, allocation timelines) або профайлер пам'яті Visual Studio.

2.  **Надмірне споживання пам'яті:**
    *   **Проблема:** Неефективне керування ресурсами, коли об'єкти, що більше не потрібні (наприклад, відрендерені сторінки), не звільняються з пам'яті.
    *   **Рішення:** Використання технік, як-от "віртуалізація сторінок" (рендерінг лише видимих сторінок) та "ліниве завантаження" (lazy loading).

3.  **Незвільнена пам'ять (Unreleased memory):**
    *   **Проблема:** У односторінкових додатках (SPA) часто залишаються невикористані дані та слухачі подій після перемикання між документами, що перешкоджає роботі збирача сміття. Приклади: проблеми з витоком пам'яті в `React PDF` та `Apryse WebViewer`.
    *   **Рішення:** Явне видалення слухачів подій та об'єктів при знищенні компонента (наприклад, у `useEffect` cleanup-функції в React).

**Практичні поради для виправлення:**

*   **Використовуйте інструменти розробника:** Регулярно аналізуйте використання пам'яті за допомогою Chrome DevTools.
    *   **Heap Snapshot:** Дозволяє побачити, які об'єкти займають пам'ять. Порівнюючи знімки до і після певної дії, можна знайти об'єкти, що не були звільнені.
    *   **Allocation Timeline:** Показує, де і коли виділяється пам'ять.
*   **Правильно керуйте слухачами подій:** Завжди видаляйте слухачі подій, коли вони більше не потрібні, щоб уникнути "detached" DOM-елементів.
*   **Очищуйте посилання на об'єкти:** Встановлюйте значення `null` для змінних, що містять великі об'єкти, коли вони більше не використовуються.
*   **Використовуйте `WeakMap` та `WeakSet`:** Для зберігання об'єктів, які можуть бути видалені збирачем сміття, якщо на них не залишиться інших посилань.

**Рішення від Syncfusion:**
Автор стверджує, що **Syncfusion JavaScript PDF Viewer** розроблений з урахуванням цих проблем і використовує передові техніки керування пам'яттю, щоб уникнути витоків та забезпечити високу продуктивність.

**Висновок:** Витоки пам'яті є серйозною проблемою для PDF-переглядачів. Розуміння їхніх причин та використання правильних інструментів для діагностики та профілактики є ключем до створення надійних та продуктивних веб-додатків.
